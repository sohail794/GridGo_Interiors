/**
 * Image Optimization Script
 * Converts images to WebP format and generates optimized sizes
 * 
 * Usage: node scripts/optimize-images.js
 * 
 * Requirements: npm install sharp glob --save-dev
 */

import sharp from 'sharp';
import { glob } from 'glob';
import path from 'path';
import fs from 'fs/promises';

const CONFIG = {
  inputDir: 'public/images',
  outputDir: 'public/images/optimized',
  backupDir: 'public/images/backup',
  sizes: {
    hero: { width: 1920, height: 1080 },
    heroMobile: { width: 768, height: 1024 },
    card: { width: 800, height: 600 },
    cardSmall: { width: 400, height: 300 },
    thumbnail: { width: 200, height: 150 },
  },
  quality: {
    webp: 80,
    avif: 75,
    jpg: 85,
  },
  formats: ['webp', 'avif'], // Output formats
};

async function ensureDir(dir) {
  try {
    await fs.mkdir(dir, { recursive: true });
  } catch (err) {
    if (err.code !== 'EEXIST') throw err;
  }
}

async function backupOriginal(filePath) {
  const fileName = path.basename(filePath);
  const backupPath = path.join(CONFIG.backupDir, fileName);
  
  try {
    await fs.copyFile(filePath, backupPath);
    console.log(`üì¶ Backed up: ${fileName}`);
  } catch (err) {
    console.error(`‚ùå Failed to backup ${fileName}:`, err.message);
  }
}

async function optimizeImage(inputPath) {
  const fileName = path.parse(inputPath).name;
  const results = [];

  try {
    const image = sharp(inputPath);
    const metadata = await image.metadata();
    
    console.log(`\nüñºÔ∏è  Processing: ${path.basename(inputPath)} (${metadata.width}x${metadata.height})`);

    // Backup original
    await backupOriginal(inputPath);

    // Generate each size variant
    for (const [sizeName, dimensions] of Object.entries(CONFIG.sizes)) {
      // Skip if original is smaller than target
      if (metadata.width < dimensions.width && metadata.height < dimensions.height) {
        console.log(`  ‚è≠Ô∏è  Skipping ${sizeName} (original smaller than target)`);
        continue;
      }

      // Generate each format
      for (const format of CONFIG.formats) {
        const outputFileName = `${fileName}-${sizeName}.${format}`;
        const outputPath = path.join(CONFIG.outputDir, outputFileName);

        try {
          let pipeline = sharp(inputPath)
            .resize(dimensions.width, dimensions.height, {
              fit: 'cover',
              position: 'center',
              withoutEnlargement: true,
            });

          if (format === 'webp') {
            pipeline = pipeline.webp({ quality: CONFIG.quality.webp });
          } else if (format === 'avif') {
            pipeline = pipeline.avif({ quality: CONFIG.quality.avif });
          }

          const info = await pipeline.toFile(outputPath);
          
          const originalSize = (await fs.stat(inputPath)).size;
          const optimizedSize = info.size;
          const savings = ((1 - optimizedSize / originalSize) * 100).toFixed(1);

          results.push({
            file: outputFileName,
            size: optimizedSize,
            savings: `${savings}%`,
          });

          console.log(`  ‚úÖ ${outputFileName} (${formatBytes(optimizedSize)}, -${savings}%)`);
        } catch (err) {
          console.error(`  ‚ùå Failed to create ${outputFileName}:`, err.message);
        }
      }
    }

    // Also create a standard optimized version (same dimensions, just compressed)
    for (const format of CONFIG.formats) {
      const outputFileName = `${fileName}-original.${format}`;
      const outputPath = path.join(CONFIG.outputDir, outputFileName);

      try {
        let pipeline = sharp(inputPath);

        if (format === 'webp') {
          pipeline = pipeline.webp({ quality: CONFIG.quality.webp });
        } else if (format === 'avif') {
          pipeline = pipeline.avif({ quality: CONFIG.quality.avif });
        }

        const info = await pipeline.toFile(outputPath);
        const originalSize = (await fs.stat(inputPath)).size;
        const savings = ((1 - info.size / originalSize) * 100).toFixed(1);

        console.log(`  ‚úÖ ${outputFileName} (${formatBytes(info.size)}, -${savings}%)`);
      } catch (err) {
        console.error(`  ‚ùå Failed to create ${outputFileName}:`, err.message);
      }
    }

  } catch (err) {
    console.error(`‚ùå Error processing ${inputPath}:`, err.message);
  }

  return results;
}

function formatBytes(bytes) {
  if (bytes === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
}

async function generateSrcsetHelper() {
  const helperContent = `/**
 * Image srcset helper for responsive images
 * Auto-generated by optimize-images.js
 */

export const imageSizes = ${JSON.stringify(CONFIG.sizes, null, 2)};

/**
 * Generate srcset string for an optimized image
 * @param baseName - Original image name without extension
 * @param sizes - Array of size names to include (default: all)
 * @returns srcset string
 */
export function getSrcset(baseName: string, sizes?: string[]): string {
  const sizesToUse = sizes || Object.keys(imageSizes);
  return sizesToUse
    .map(size => {
      const { width } = imageSizes[size as keyof typeof imageSizes];
      return \`/images/optimized/\${baseName}-\${size}.webp \${width}w\`;
    })
    .join(', ');
}

/**
 * Get optimized image path
 * @param baseName - Original image name without extension
 * @param size - Size variant
 * @param format - Image format (default: webp)
 */
export function getOptimizedImage(
  baseName: string, 
  size: keyof typeof imageSizes = 'card',
  format: 'webp' | 'avif' = 'webp'
): string {
  return \`/images/optimized/\${baseName}-\${size}.\${format}\`;
}
`;

  await fs.writeFile(
    path.join('src', 'utils', 'images.ts'),
    helperContent,
    'utf-8'
  );
  console.log('\nüìù Generated src/utils/images.ts helper');
}

async function main() {
  console.log('üöÄ Starting image optimization...\n');

  // Ensure directories exist
  await ensureDir(CONFIG.outputDir);
  await ensureDir(CONFIG.backupDir);

  // Find all images
  const patterns = [
    `${CONFIG.inputDir}/**/*.{jpg,jpeg,png,gif}`,
    `${CONFIG.inputDir}/*.{jpg,jpeg,png,gif}`,
  ];

  let allImages = [];
  for (const pattern of patterns) {
    const images = await glob(pattern, { ignore: ['**/optimized/**', '**/backup/**'] });
    allImages = [...allImages, ...images];
  }

  // Remove duplicates
  allImages = [...new Set(allImages)];

  if (allImages.length === 0) {
    console.log('üì≠ No images found to optimize.');
    console.log(`   Looking in: ${CONFIG.inputDir}`);
    console.log('\nüí° Tip: Add images to public/images/ and run this script again.');
    return;
  }

  console.log(`üì∏ Found ${allImages.length} image(s) to optimize\n`);

  // Process each image
  const allResults = [];
  for (const imagePath of allImages) {
    const results = await optimizeImage(imagePath);
    allResults.push(...results);
  }

  // Generate helper utility
  await generateSrcsetHelper();

  // Summary
  console.log('\n' + '='.repeat(50));
  console.log('üìä Optimization Summary');
  console.log('='.repeat(50));
  console.log(`   Images processed: ${allImages.length}`);
  console.log(`   Variants created: ${allResults.length}`);
  console.log(`   Output directory: ${CONFIG.outputDir}`);
  console.log(`   Backups saved to: ${CONFIG.backupDir}`);
  console.log('\n‚ú® Done!\n');
}

main().catch(console.error);
